
-- 1. EXTENSIONS (If not already enabled)
-- Supabase projects typically have these enabled by default, but this ensures it.
create extension if not exists "uuid-ossp" with schema "extensions";

-- 2. ENUM TYPES
-- Create custom types for roles and categories to ensure data consistency.
-- The roles match what's used in your AuthContext.tsx
create type public.user_role as enum ('admin', 'recepcion', 'trainer');
create type public.plan_category as enum ('monthly', 'session', 'special');

-- 3. PROFILES TABLE
-- This table stores public data for your app's users (staff, admins, trainers).
-- It is linked to Supabase's internal auth.users table.
create table public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  full_name text,
  role user_role not null
);

-- 4. CLIENTES (GYM MEMBERS) TABLE
create table public.clientes (
  id bigint generated by default as identity primary key,
  nombre text not null,
  apellido text not null,
  correo text unique,
  telefono text,
  codigo char(6) unique not null,
  activo boolean default true not null,
  fecha_registro timestamp with time zone default now() not null,
  -- Add a constraint for the email format
  constraint clientes_correo_check check (correo ~* '^[A-Za-z0-9._+%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$')
);

-- 5. PLANES TABLE
-- Stores all subscription plans. The 'categoria' column is added to match your PlanSelector.tsx component.
create table public.planes (
  id bigint generated by default as identity primary key,
  nombre text not null,
  precio numeric(10, 2) not null,
  categoria plan_category not null,
  -- Description can hold details like "Acceso completo", "3 veces por semana", etc.
  descripcion text,
  entradas integer default 31 not null,
  horario text default 'completo' not null
);

-- 6. SUSCRIPCIONES TABLE
-- Links a cliente to a plan.
create table public.suscripciones (
  id bigint generated by default as identity primary key,
  cliente_id bigint not null references public.clientes on delete cascade,
  plan_id bigint not null references public.planes on delete set null,
  fecha_inicio date not null,
  fecha_fin date not null,
  -- The status can be derived, but storing it can simplify queries.
  estado text default 'Activo' not null,
  -- Foreign key to the user who created the subscription. Linked to the UUID of auth.users
  creado_por_usuario_id uuid references auth.users(id) on delete set null,
  constraint chk_fechas check (fecha_fin >= fecha_inicio)
);

-- 7. PRODUCTOS (INVENTORY) TABLE
create table public.productos (
  id bigint generated by default as identity primary key,
  nombre text not null,
  categoria text,
  precio numeric(10, 2) not null,
  stock integer default 0 not null,
  -- A description can be useful for the sales dialog
  descripcion text
);

-- 8. VENTAS (SALES) TABLE
create table public.ventas (
  id bigint generated by default as identity primary key,
  -- A sale can be to a registered client or a walk-in, so cliente_id is optional.
  cliente_id bigint references public.clientes on delete set null,
  nombre_cliente_temporal text, -- For walk-in customers
  fecha timestamp with time zone default now() not null,
  total numeric(10, 2) not null,
  estado text default 'Completada' not null,
  -- Foreign key to the user who made the sale
  vendedor_usuario_id uuid references auth.users(id) on delete set null
);

-- 9. VENTAS_PRODUCTOS (JOIN TABLE FOR SALES)
create table public.ventas_productos (
  venta_id bigint not null references public.ventas on delete cascade,
  producto_id bigint not null references public.productos on delete restrict,
  cantidad integer not null,
  precio_unitario numeric(10, 2) not null,
  primary key (venta_id, producto_id)
);

-- 10. ENTRENAMIENTOS (EXERCISES) TABLE
create table public.entrenamientos (
  id bigint generated by default as identity primary key,
  nombre text not null,
  categoria text,
  maquina text,
  descripcion text,
  imagen_url text
);

-- 11. REGISTROS_ENTRADA (CLIENT CHECK-INS) TABLE
create table public.registros_entrada (
  id bigint generated by default as identity primary key,
  cliente_id bigint not null references public.clientes on delete cascade,
  suscripcion_id bigint not null references public.suscripciones on delete cascade,
  fecha_entrada timestamp with time zone default now() not null
);

-- 12. ROW LEVEL SECURITY (RLS) SETUP
-- IMPORTANT: Enable RLS on each table after creating policies.
-- This is a starter set of policies. You should refine them based on your exact needs.

-- PROFILES
alter table public.profiles enable row level security;
create policy "Los usuarios pueden ver todos los perfiles." on public.profiles for select using (true);
create policy "Los usuarios pueden actualizar su propio perfil." on public.profiles for update using (auth.uid() = id);

-- CLIENTES
alter table public.clientes enable row level security;
create policy "El personal autenticado puede gestionar clientes." on public.clientes for all
  using ( (select role from public.profiles where id = auth.uid()) in ('admin', 'recepcion') );

-- PLANES
alter table public.planes enable row level security;
create policy "Los administradores pueden gestionar planes." on public.planes for all
  using ( (select role from public.profiles where id = auth.uid()) = 'admin' );
create policy "El personal autenticado puede leer planes." on public.planes for select
  using ( (select role from public.profiles where id = auth.uid()) in ('admin', 'recepcion') );

-- SUSCRIPCIONES
alter table public.suscripciones enable row level security;
create policy "El personal autenticado puede gestionar suscripciones." on public.suscripciones for all
  using ( (select role from public.profiles where id = auth.uid()) in ('admin', 'recepcion') );

-- PRODUCTOS
alter table public.productos enable row level security;
create policy "El personal autenticado puede gestionar productos." on public.productos for all
  using ( (select role from public.profiles where id = auth.uid()) in ('admin', 'recepcion') );

-- VENTAS
alter table public.ventas enable row level security;
create policy "El personal autenticado puede gestionar ventas." on public.ventas for all
  using ( (select role from public.profiles where id = auth.uid()) in ('admin', 'recepcion') );

-- VENTAS_PRODUCTOS
alter table public.ventas_productos enable row level security;
create policy "El personal autenticado puede gestionar detalles de ventas." on public.ventas_productos for all
  using ( (select role from public.profiles where id = auth.uid()) in ('admin', 'recepcion') );

-- ENTRENAMIENTOS
alter table public.entrenamientos enable row level security;
create policy "Los entrenadores y admins pueden gestionar entrenamientos." on public.entrenamientos for all
  using ( (select role from public.profiles where id = auth.uid()) in ('admin', 'trainer') );
create policy "El personal autenticado puede ver entrenamientos." on public.entrenamientos for select
  using ( auth.role() = 'authenticated' );

-- REGISTROS_ENTRADA
alter table public.registros_entrada enable row level security;
create policy "El personal autenticado puede gestionar registros de entrada." on public.registros_entrada for all
  using ( (select role from public.profiles where id = auth.uid()) in ('admin', 'recepcion') );

-- Function to create a profile for a new user
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, role, full_name)
  values (new.id, 'recepcion', new.raw_user_meta_data->>'full_name'); -- Default role is 'recepcion'
  return new;
end;
$$;

-- Trigger to execute the function on new user creation
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
